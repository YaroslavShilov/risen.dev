---
title: Готовим селекторы
date: "2020-02-02T15:35:13.916Z"
description: "Их можно делать и без reselect!"
---

По примеру из репозитория `reselect` может сложиться неправильное понимание того, как селекторы стоит использовать.

Лично я, только ознакомившись с этой библиотекой, принялся абсолютно каждый селектор создавать через `createSelector`. Такой подход конечно же неправильный, и мемоизированные селекторы полезны не во всех случаях.

В этой небольшой статье я попробую обьяснить, как нужно писать селекторы в разных ситуациях.

## Какие варианты? {#what-options}

Варианта 2:

- Мемоизированные селекторы, созданные через `createSelector` из `reselect`
- Селекторы без мемоизации, в которых мы ручками принимаем `state` и возвращаем нужные данные

## С мемоизацией {#memoized}

Рассмотрим сценарии применения мемоизированных селекторов.

### Тяжелые вычисления {#heavy-computations}

```js
// только оплаченные элементы
const paidItems = createSelector(
  items,
  items => items.filter(filters.onlyPaid)
)

// только оплаченная сумма
const paidAmount = createSelector(
  paidItems,
  items => items.reduce(reducers.total, 0)
)

// общая сумма покупок
const totalAmount = createSelector(
  items,
  items => items.reduce(reducers.total, 0)
)
```

Нам не нужно заново рассчитывать что-либо, если входные параметры не изменились.
  
Любое стейта заставляет все `mapStateToProps` и `useSelector` выполниться. В случае, если мы будем использовать не мемоизированную функцию, все тяжелые вычисления в селекторах будут произведены заново, вне зависимости от того, были ли входные данные селекторов задеты изменением в стейте.

А это означает, что если покупатель откроет/закроет какую-нибудь глобальную модалку, состояние которой лежит в редакс сторе, сумма покупок рассчитается заново, не смотря на то, что состояние модалок не имеет никакого отношения к корзине покупок.

### Преобразование данных {#data-mapping}

```js
const loadingState = createSelector(
  isLoading,
  isLoaded,
  isFailed,
  (isLoading, isLoaded, isFailed) => ({
    isLoading,
    isLoaded,
    isFailed
  })
)
```

Хоть данный селектор и не производит тяжелых вычислений, но он возвращает объект.

Если не выполнять мемоизацию, при каждом вызове такой селектор будет возвращать новый объект, в том числе когда все входные данные остались прежними. `mapStateToProps` и `useSelector` при неглубоком сравнении посчитают, что данные изменились, и компонент будет перерендерен.

Мемоизированный же селектор будет возвращать ссылку на старый объект, если входные данные не изменились, соответственно лишних ререндеров не будет.

Все это относится к любым значениям, имеющим ссылочный тип данных (массивы, инстансы `Date`, `Map`, `Set` и т.д.). Для простоты представителем подобных значений дальше будет выступать объект.

Возможен и другой случай:

```js
const somePrimitive = createSelector(
  isA,
  isB,
  isC,
  (isA, isB, isC) => {
    return isA && isB && isC
  }
)
```

Этот селектор возвращает примитивное значение и не делает никаких тяжелых расчетов. Так что с точки зрения оптимизации нам не нужно здесь использовать `createSelector`. Более того, мемоизированный селектор будет выполнять больше вычислений и занимать больше памяти (хоть и ненамного).

А вот то же самое обычным селектором:

```js
const somePrimitive = state => {
  return isA(state) && isB(state) && isC(state)
}
```

К сожалению, такой селектор не так чисто выглядит и при увеличении зависимостей начинает расти в ширину, а не в высоту, поэтому быстро приходит в нечитабельное состояние. А если попытаться исправить это, мы столкнемся с конфликтами между именами селекторов и переменных.

В таких случаях я отдаю предпочтение версии c `createSelector`, хоть она и уступает по производительности. В контексте всего приложения разница будет несущественная.

## Без мемоизации {#not-memoized}

```js
const everything = state => state.cart

const items = state => everything(state).items

const calculation = state => everything(state).calculation

// композировать тоже можно
const bonuses = state => calculation(state).bonuses
```

Такие селекторы стоит использовать всегда, когда мы напрямую ссылаемся на данные из стора.

Даже если возвращаемое значение является объектом, не стоит беспокоиться - мы лишь возвращаем ссылку на уже существующий объект, который находится в стейте, так что ни к каким проблемам это не приведет.

Мемоизированные селекторы в подобных случаях использовать не стоит -- из-за проверки входных данных и сравнения их с предыдущими, такие селекторы будут медленнее (~ в 30 раз), а обьем занимаемой памяти увеличится, так как предыдущие входные данные нужно где-то хранить. Проблема с памятью не очень заметна, но становится вполне ощутима, когда входными данными является обьект с кучей данных.

## Заключение {#conclusion}

**Используем обычные селекторы без мемоизации когда:**

- Нужно просто достать значение из стора
- *(не обязательно)* Нужно сделать простую операцию над каким-то значением, при этом результатом этой операции является примитивное значение

**Используем мемоизированные селекторы когда:**

- В селекторе есть тяжелые вычисления (сумма покупок, фильтрация, преобразование данных и так далее)
- Результатом вызова селектора является значение с ссылочным типом данных